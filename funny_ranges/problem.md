# -*- coding:utf-8 -*-
#+OPTIONS: h:3 toc:3 num:3 ^:{}
#+STARTUP: indent content
#+TITLE: HihoCoder #1622 有趣的子区间

* #1622 : 有趣的子区间

http://hihocoder.com/problemset/problem/1622

时间限制:10000ms
单点时限:1000ms
内存限制:256MB

** 描述

如果一个区间[a, b]内恰好包含偶数个回文整数，我们就称[a, b]是有趣的区间。

例如[9, 12]包含两个回文整数9和11,所以[9, 12]是有趣的区间。[12, 20]包含
0个回文整数，所以[12, 20]也是有趣的。

现在给定一个区间[a, b]，请你求出[a, b]中所有满足a ≤ p ≤ q ≤ b的子区
间[p, q]有多少个有趣的。

** 输入

第一行包含两个整数a和b。  

对于30%的数据，1 ≤ a ≤ b ≤ 1000  

对于60%的数据，1 ≤ a ≤ b ≤ 100000  

对于100%的数据, 1 ≤ a ≤ b ≤ 1000000000

** 输出

有趣的子区间数目

*** 样例输入

:    10 20

*** 样例输出

:    46

** 解题思路

*** 回文数

定义： 一个正整数，从左向右读和从右向左读，其值是相同的。例子：
+  0
+  1~9
+  11
+  121
+  123321


*** 输入区间

要求是`a <= p <= q <= b'。因此对于输入区间可以有两种情况：
1.   a = b, e.g [11,11],[13,13]
2.   a < b, e.g [0,3],[10,20]


*** 区间内的回文数个数

(a) 若含有1、3、5...等奇数个回文数，则不算做有趣的区间。例如，区间
[9,9]只有一个回文数，不算有趣的区间。

(b) 若含有2、4、6...等偶数个回文数，算作有趣的区间。例如，区间[8,9]有
两个回文数，算有趣的区间。

(c) 若含有0个回文数，也算作有趣的区间。例如，区间[12,20]有0个回文数，
算有趣的区间。


*** 对输入区间按回文数做划分

很容易想到，对给定输入区间做划分。分为两类，含有回文数的子区间，不含有
回文数的子区间。其中每个回文数单独作为一个子区间。那么一个有趣的区间，
其实就是要跨越0个或者2个、4个...等偶数个回文数子区间的两个数p,q组成的区间。
例如，对于区间[10,20]，首先可以按回文数划分成如下子区间：
:  S1. {10}
:  S2. {11}
:  S3. {12,13,14,15,16,17,18,19,20}
也可以把每个子区间叫做一个集合（set）。可以从任意两个集合里各取出一个
数来，构成一个子区间。把总的符合要求的子区间数量记为F。F的初值就是0。

*** 统计有趣区间的数量

**** 分析
子区间[p,q]的头端值p，可以首先从S1里取一个值10。接下来区间尾端值q，可
以从S1、S2、S3三个区间里取（要注意，需满足q>=p）。

首先看S1。S1里只有一个数，q取10。得到区间[10,10]。由于这个区间没有跨越
任何回文数区间，因此包含0个回文数，是一个有趣子区间。F值加一，即F=1。

接下来看S2。S2里第一个数是11（也是唯一的数）。这个集合同时也是一个回文
数集合。回文数集合按照我们的划分方法，仅有一个数。这里q取11,得到的区间
是[10,11]。这个区间跨越（或者说包含）了一个回文数区间，因此不符合要求。

继续看S3。S3有9个数。无论q取哪个数，与值10构成的子区间都包含一个回文数
区间，因此都不符合要去。

现在q的取值已经遍历完了所有的集合。可以让p取下一个数。S1只有一个数，于
是p只能取s2的11。当q取s2的11时，构成区间[11,11]，仅包含一个回文数，不
符合要求。q取s3中的数，结果也是一样。到此时为止，F=1。

然后p就可以取s3中的数12。q>=p，因此q可以取的值有9个，即12～20。p取下一
个13，那q可取的数有8个，...，以此类推，当p取20的时候，q也只能取20。从
s3中取出的两个数p，q组成的区间不含回文数，符合要求。因此F的值有增加：
:  F = F + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 
:  F = F + 9*(9+1)/2
:  F = 1 + 45
:  F = 46

**** 归纳

从以上分析可以看出，只需要知道划分后每个集合的大小，以及是否回文数集合，
就可以在集合层面上做计算，而不需要遍历每个元素。

(1) 非回文数集合。设集合的大小是n。满足要求的子区间数就是
:  n(n+1)/2

(2) 回文数集合。按照我们的划分方法，每个回文数集合仅有一个数。满足要求
的子区间数是0。

(3) 跨越多个集合。按照我们的划分方法，每个非回文数集合的邻居，或者是空，
或者是回文数集合。而一个回文数集合的邻居，或者是空，或者是回文数集合，
或者是非回文数集合。如果要满足有趣子区间，则pq的取值就要根据p所属集合
的类别，决定q至少跨越的回文数集合的个数。

设有N个集合，依次为S[0],S[1],S[2],S[n-1]。对于第i个集合S[i](0<=i<n)来
说，从S[i+1]开始，遍历所有剩余集合。将S[i]包括在内，若含有偶数个回文数
区间，就可以计算满足要求的子区间。

设S[i]和S[j]中的数组成的区间符合要求，且S[i]中有n个数，S[j]中有m个数。
则符合要求子区间数有：
: n x m

** C语言实现

*** 随机生成一定数量的区间并保存在文件中

生成的数据分布，要满足题目的要求，即：
+    1 <= n <= 1000,  30%
+    1001 <= n <= 100000, 30%
+    100001 <= n <= 1000000000, 40%

#+BEGIN_SRC c
  /* 生成total个区间并保存到filename指定的文件，每个区间占一行。
   ,* 各种大小的区间的数量、比例以及上界分别由入参num_of_ratios, 数组ratio和ubound给出。
   ,* 函数返回实际生成的区间数量。返回-1表示错误发生。
   ,*/
  #include <stdlib.h>
  #include <time.h>

  int
  create_ranges(const char* filename, unsigned long total )
  {
    int begin=0, end=0;
    int i = 0;
    unsigned long cnt1 = 0;			/* 1 <= n <= 1000; 30% */
    unsigned long cnt2 = 0;			/* 1001 <= n <= 100000; 30% */
    unsigned long cnt3 = 0;                	/* 100001 <= n <= 1000000000; 40% */
  
    time_t t = time(NULL);
    srandom((unsigned int)t);

    if ( total < 3 ) {
      return -1;
    }
  
    cnt1 = total * 30 

    for (i = 0; i < total; ++i) {

    }
  }
#+END_SRC

*** 读取输入区间
文件内有很多行，每一行包含两个数，表示一个输入区间。
#+BEGIN_SRC c
  /*  */
  int input(char* file, int* a, int *b)
  {

  }
#+END_SRC
